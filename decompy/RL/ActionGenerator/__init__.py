# from decompy.RL.ActionGenerator.RetdecPassActions import

__all__ = []

# there are a few useful flags I found (list at: https://github.com/blacktop/docker-retdec)
# the list of useful flags:
# two useful flags for optimizations: `--backend-enabled-opts list` and `--backend-disabled-opts list` where `list` is a comma separated list.

# list of available passes from retdec:
# GotoStmtOptimizer ( 0.48s )
# RemoveUselessCastsOptimizer ( 0.48s )
# UnusedGlobalVarOptimizer ( 0.48s )
# DeadLocalAssignOptimizer ( 0.48s )
# SimpleCopyPropagationOptimizer ( 0.48s )
# CopyPropagationOptimizer ( 0.48s )
# AuxiliaryVariablesOptimizer ( 0.48s )
# SimplifyArithmExprOptimizer ( 0.48s )
# IfStructureOptimizer ( 0.48s )
# LoopLastContinueOptimizer ( 0.48s )
# PreWhileTrueLoopConvOptimizer ( 0.48s )
# WhileTrueToForLoopOptimizer ( 0.48s )
# WhileTrueToWhileCondOptimizer ( 0.48s )
# IfBeforeLoopOptimizer ( 0.48s )
# LLVMIntrinsicsOptimizer ( 0.48s )
# VoidReturnOptimizer ( 0.48s )
# BreakContinueReturnOptimizer ( 0.48s )
# BitShiftOptimizer ( 0.48s )
# DerefAddressOptimizer ( 0.48s )
# EmptyArrayToStringOptimizer ( 0.48s )
# BitOpToLogOpOptimizer ( 0.48s )
# SimplifyArithmExprOptimizer ( 0.48s )
# UnusedGlobalVarOptimizer ( 0.48s )
# DeadLocalAssignOptimizer ( 0.48s )
# SimpleCopyPropagationOptimizer ( 0.48s )
# CopyPropagationOptimizer ( 0.48s )
# SelfAssignOptimizer ( 0.48s )
# VarDefForLoopOptimizer ( 0.48s )
# VarDefStmtOptimizer ( 0.48s )
# EmptyStmtOptimizer ( 0.48s )
# GotoStmtOptimizer ( 0.48s )
# SimplifyArithmExprOptimizer ( 0.48s )
# DeadCodeOptimizer ( 0.48s )
# DerefToArrayIndexOptimizer ( 0.48s )
# IfToSwitchOptimizer ( 0.48s )
# CCastOptimizer ( 0.48s )
# CArrayArgOptimizer ( 0.48s )

# no optimizations: `--backend-no-opts`, however we still get some optimizations... However, the output is drastically different and less readable.
# Running phase: Main function identification optimization ( 0.73s )
# Running phase: Libgcc idioms optimization ( 0.73s )
# Running phase: LLVM instruction optimization ( 0.73s )
# Running phase: Conditional branch optimization ( 0.73s )
# Running phase: Syscalls optimization ( 0.73s )
# Running phase: Stack optimization ( 0.73s )
# Running phase: Constants optimization ( 0.73s )
# Running phase: Function parameters and returns optimization ( 0.73s )
# Running phase: Register localization optimization ( 0.73s )
# Running phase: LLVM instruction optimization ( 0.73s )
# Running phase: Simple types recovery optimization ( 0.73s )
# Running phase: Disassembly generation ( 0.73s )
# Running phase: Assembly mapping instruction removal ( 0.73s )
# Running phase: C++ class hierarchy optimization ( 0.73s )
# Running phase: Selected functions optimization ( 0.73s )
# Running phase: Unreachable functions optimization ( 0.73s )
# Running phase: LLVM instruction optimization ( 0.73s )
# Running phase: x86 address spaces optimization ( 0.73s )
# Running phase: Value protection optimization ( 0.73s )
# Running phase: LLVM ( 0.73s )
# Running phase: Simple types recovery optimization ( 0.75s )
# Running phase: Stack pointer operations optimization ( 0.75s )
# Running phase: LLVM instruction optimization ( 0.75s )
# Running phase: Instruction idioms optimization ( 0.75s )
# Running phase: Global to local optimization ( 0.75s )
# Running phase: Dead global assign optimization ( 0.75s )
# Running phase: LLVM ( 0.75s )
# Running phase: Phi2Seq optimization ( 0.75s )
# Running phase: Value protection optimization ( 0.75s )
# Running phase: LLVM ( 0.75s )
# Running phase: Bitcode Writer ( 0.75s )
# Running phase: Assembly Writer ( 0.75s )
# Running phase: Cleanup ( 0.75s )